/**
 * Collection organization scheme:
 *
 * Users
 * --------
 * This collection is created by the account package.
 *  _id:            User id generated on registration
 *  username:       Unused
 *  email:          Users email (and sign in)
 *  password
 *  queries:        Array of queries that the user added. This may include queries that the user doesn't own
 *  starredQueries: Array of queries that the user starred
 *
 * Queries
 * --------
 *  _id:            Generated by mongo, used as the URL to access it (/query/_id)
 *  name:           A user given name for the query, nullable
 *  regions:        Array referencing regions._id that were a part of this query
 *  createdDate:    Date the query was created
 *  owner:          userID of the user that created the query, or null if anon
 *  filters:        Array of filters to perform on junctions. Each filter has the format:
 *                  {  "filter" : "junctions.xxx",
 *                      "op" : "some_mongo_operator",
 *                      "val" : some_value
 *                  }
 *  groups:         Array of user selected groups of junctionIds.
 *                  These junctions may no longer be in the query if the relevant region was removed,
 *                  or if a filter removes it. Each group has the format:
 *                  {   "_id" : "id"
 *                      "name" : "group name",
 *                      "junctions" : [...]
 *                  }
 *
 *  processors:     Array of processor configs and results. The processors use junction groups,
 *                  which may be deleted after a processor is created. Each has the following format.
 *                  inputGroup and type matches what's found in the index.
 *                  {   "_id" : "id",
 *                      "type" : "processor type key from index",
 *                      "inputGroups" : {    "inputGroup[0]" : groupId,
 *                                           "inputGroup[1]" : groupId,
 *                                            ...
 *                                      },
 *                      "results" : someObj,
 *                      "params" : {    "someParam" : someVal, ...}
 *
 *                  }
 *
 *
 *  Regions
 *  --------
 *  _id:            Lower case and trimmed ID of the region used in the Snaptron query. E.G: "cd99", "ch6:1-1000"
 *  loadedDate:     Date when this was loaded. null if never loaded (or failed to load)
 *  junctions:      Array of junctions._id
 *  metadata:       Array of {key:"someKey", value:"someValue"} metadata elements returned by Snaptron
 *  models:         Array of gene model objects. See the schema for the format of a model object
 *
 *  Junctions
 *  ---------
 *  _id:            Value of snaptron_id returned by Snaptron
 *
 *  ** The rest of the fields are generated by Snaptron's response. The following are assumed to exist**
 *  samples_count
 *  coverage_sum
 *  coverage_avg
 *  coverage_median
 *  start
 *  stop
 *  length
 *
 *  Samples
 *  ---------
 *  _id:            Value of sample_id returned by Snaptron
 *
 *  The rest of the fields are dependant on what is returned by Snaptron
 */

//<editor-fold desc="Collection Globals">
SAMPLE_ID_FIELD = "intropolis_sample_id_i";

USER_QRYS          = "queries";
USER_STARRED_QRYS  = "starredQueries";
USER_USERNAME      = "username";
USER_EMAILS        = "emails";
USER_EMAIL_ADDRESS = "address";
USER_PROFILE       = "profile";

QRY_NAME         = "name";
QRY_REGIONS      = "regions";
QRY_FILTERS      = "filters";
QRY_CREATED_DATE = "createdDate";
QRY_OWNER        = "owner";
QRY_GROUPS       = "groups";
QRY_GROUP_NAME   = "name";
QRY_GROUP_JNCTS  = "junctions";

QRY_FILTER_FIELD        = "filter";
QRY_FILTER_OP           = "op";
QRY_FILTER_VAL          = "val";
QRY_FILTER_SAMPLE_COUNT = "samples_count";
QRY_FILTER_COV_SUM      = "coverage_sum";
QRY_FILTER_COV_AVG      = "coverage_avg";
QRY_FILTER_COV_MED      = "coverage_median";
QRY_FILTER_LENGTH       = "length";

QRY_PROCESSORS             = "processors";
QRY_PROCESSOR_TYPE         = "type";
QRY_PROCESSOR_INPUT_GROUPS = "inputGroups";
QRY_PROCESSOR_RESULTS      = "results";
QRY_PROCESSOR_PARAMS       = "params";

REGION_METADATA         = "metadata";
REGION_LOADED_DATE      = "loadedDate";
REGION_JUNCTIONS        = "junctions";
REGION_METADATA_KEY     = "key";
REGION_METADATA_VAL     = "value";
REGION_MODELS           = "models";
REGION_MODEL_SRC_TYPE   = "sourceType";
REGION_MODEL_REF        = "reference";
REGION_MODEL_SRC        = "source";
REGION_MODEL_FEAT_TYPE  = "featureType";
REGION_MODEL_START      = "start";
REGION_MODEL_END        = "end";
REGION_MODEL_STRAND     = "strand";
REGION_MODEL_TRANSCRIPT = "transcript";
REGION_MODEL_CDS_START  = "cdsStart";
REGION_MODEL_CDS_END    = "cdsEnd";
REGION_MODEL_EXONS      = "exons";

JNCT_ID_FIELD      = "snaptron_id";
JNCT_ANNOTATED_KEY = "annotated?";
JNCT_SAMPLES_KEY   = "samples";
JNCT_COVERAGE_KEY  = "read_coverage_by_sample";
JNCT_COL_TYPES     = {
    "DataSource:Type": "str",
    "snaptron_id": "str",
    "chromosome": "str",
    "start": "int",
    "end": "int",
    "length": "int",
    "strand": "str",
    "annotated?": "bool",
    "left_motif": "str",
    "right_motif": "str",
    "left_annotated?": "str",
    "right_annotated?": "str",
    "samples": "str[]",
    "read_coverage_by_sample": "float[]",
    "samples_count": "int",
    "coverage_sum": "float",
    "coverage_avg": "float",
    "coverage_median": "float",
    "source_dataset_id": "str"
};
//</editor-fold>

Users     = Meteor.users;
Queries   = new Mongo.Collection("queries");
Regions   = new Mongo.Collection("regions");
Junctions = new Mongo.Collection("junctions");
Samples   = new Mongo.Collection("samples");

SnapApp.Schemas.UserSchema           = new SimpleSchema({
    /**
     * This schema adapted from the collection2 github README.
     */
    username: {
        type: String,
        optional: true,
        label: "Username"
    },
    emails: {
        type: Array,
        label: "Emails",
        optional: true
    },
    "emails.$": {
        type: Object
    },
    "emails.$.address": {
        type: String,
        regEx: SimpleSchema.RegEx.Email
    },
    "emails.$.verified": {
        type: Boolean
    },
    createdAt: {
        type: Date
    },
    profile: {
        type: Object,
        optional: true
    },
    // Make sure this services field is in your schema if you're using any of the accounts packages
    services: {
        type: Object,
        optional: true,
        blackbox: true
    },
    // If you specify that type as Object, you must also specify the
    // `Roles.GLOBAL_GROUP` group whenever you add a user to a role.
    // Example:
    // Roles.addUsersToRoles(userId, ["admin"], Roles.GLOBAL_GROUP);
    roles: {
        type: Object,
        optional: true,
        blackbox: true
    },
    // In order to avoid an 'Exception in setInterval callback' from Meteor
    heartbeat: {
        type: Date,
        optional: true
    },
    queries: {
        type: [String],
        label: "User Queries",
        defaultValue: []
    },
    starredQueries: {
        type: [String],
        label: "User Starred Queries",
        defaultValue: []
    }
});
SnapApp.Schemas.QueryFilterSchema    = new SimpleSchema({
    filter: {
        type: String,
        label: "Filter Field"
    },
    op: {
        type: String,
        label: "Filter Operator",
        allowedValues: [MONGO_OPERATOR_EQ, MONGO_OPERATOR_GT,
            MONGO_OPERATOR_LT, MONGO_OPERATOR_GTE, MONGO_OPERATOR_LTE]
    },
    val: {
        type: Number,
        label: "Filter Value"
    }
});
SnapApp.Schemas.QueryProcessorSchema = new SimpleSchema({
    _id: {
        type: String,
        label: "Processor ID"
    },
    type: {
        type: String,
        label: "Processor Type"
    },
    inputGroups: {
        type: Object,
        label: "Processor Groups",
        blackbox: true,
        defaultValue: {}
    },
    results: {
        type: Object,
        label: "Processor Results",
        blackbox: true,
        optional: true
    },
    params: {
        type: Object,
        blackbox: true,
        label: "Processor Params"
    }
});
SnapApp.Schemas.QueryGroupSchema     = new SimpleSchema({
    _id: {
        type: String,
        label: "Group ID"
    },
    name: {
        type: String,
        label: "Group Name"
    },
    junctions: {
        type: [String],
        label: "Group Junctions"
    }
});
SnapApp.Schemas.QuerySchema          = new SimpleSchema({
    name: {
        type: String,
        optional: true,
        label: "Name"
    },
    regions: {
        type: [String],
        label: "Regions",
        defaultValue: []
    },
    createdDate: {
        type: Date,
        label: "Created Date"
    },
    owner: {
        type: String,
        label: "Owner ID",
        optional: true
    },
    filters: {
        type: [SnapApp.Schemas.QueryFilterSchema],
        label: "Filters",
        defaultValue: []
    },
    groups: {
        type: [SnapApp.Schemas.QueryGroupSchema],
        label: "Groups",
        defaultValue: []
    },
    processors: {
        type: [SnapApp.Schemas.QueryProcessorSchema],
        label: "Processors",
        defaultValue: []
    }
});
SnapApp.Schemas.RegionModelSchema    = new SimpleSchema({
    sourceType: {
        type: String,
        label: "DataSource:Type"
    },
    reference: {
        type: String,
        label: "Reference"
    },
    source: {
        type: String,
        label: "Annotation Source"
    },
    featureType: {
        type: String,
        label: "Feature Type"
    },
    start: {
        type: Number,
        label: "Start"
    },
    end: {
        type: Number,
        label: "End"
    },
    strand: {
        type: String,
        label: "Strand",
        allowedValues: ["+", "-", ""]
    },
    transcript: {
        type: String,
        label: "Transcript ID"
    },
    cdsStart: {
        type: Number,
        label: "Coding Region Start"
    },
    cdsEnd: {
        type: Number,
        label: "Coding Region End"
    },
    exons: {
        type: Array,
        label: "Exons"
    },
    "exons.$": {
        type: Object
    },
    "exons.$.start": {
        type: Number,
        label: "Exon Start"
    },
    "exons.$.end": {
        type: Number,
        label: "Exon End"
    }
});
SnapApp.Schemas.RegionSchema         = new SimpleSchema({
    loadedDate: {
        type: Date,
        optional: true,
        label: "Loaded Date"
    },
    junctions: {
        type: [String],
        label: "Junctions",
        defaultValue: []
    },
    metadata: {
        type: [Object],
        defaultValue: [],
        blackbox: true,
        label: "Metadata"
    },
    models: {
        type: [SnapApp.Schemas.RegionModelSchema],
        defaultValue: [],
        label: "Models"
    }
});

Users.attachSchema(SnapApp.Schemas.UserSchema);
Queries.attachSchema(SnapApp.Schemas.QuerySchema);
Regions.attachSchema(SnapApp.Schemas.RegionSchema);

if (Meteor.isServer) {
    // Index all text attributes for sample searching
    Samples._ensureIndex({
        "$**": "text"
    }, {
        weights: {
            /**
             * Large weights for identifier attrs, and titles/descriptions of samples
             */
            run_accession_s: 10,
            sample_accession_s: 10,
            experiment_accession_s: 10,
            study_accession_s: 10,
            experiment_title_t: 10,
            study_title_t: 10,
            study_abstract_t: 5,
            study_type_t: 5,
            sample_attribute_t: 5,
            cell_type_t: 5
        }
    });
}

Meteor.methods({
    /**
     * If the current user is an admin, clears all loaded
     * samples, junctions, and regions
     */
    "resetSnaptronData": function () {
        if (Roles.userIsInRole(Meteor.user(), ['admin'])) {
            Samples.remove({});
            Junctions.remove({});
            Regions.remove({});
        }
    }
});